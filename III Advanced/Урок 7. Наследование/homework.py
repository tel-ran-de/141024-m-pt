# Создайте класс TrackedDict, который наследует от встроенного типа dict и добавляет новые методы
# для отслеживания изменений в словаре. Используйте private и protected атрибуты для хранения состояния и
# добавьте методы для работы с этими атрибутами. Также проверьте, является ли TrackedDict подклассом dict с
# помощью функции issubclass() и используйте super() для вызова методов суперкласса.
#
# Шаги:
# Создайте класс TrackedDict, который наследует от dict.
# Добавьте private атрибут для хранения количества изменений (добавление/удаление элементов).
# Добавьте protected атрибут для хранения разрешенного количества изменений.
# Переопределите методы __setitem__ и __delitem__, чтобы увеличивать счетчик изменений и проверять его значение.
# Напишите методы для получения значений private и protected атрибутов.
# Проверьте, является ли TrackedDict подклассом dict с помощью функции issubclass().


# def __setitem__(self, key, value):
#     if self.__change_count >= self._max_changes:
#         print("Cannot add/change item: maximum number of changes reached")
#     else:
#         super().__setitem__(key, value)
#         self.__change_count += 1


# Создайте класс ExtendedList, который наследует от встроенного типа list и добавляет несколько новых методов.
# Используйте private и protected атрибуты для хранения состояния и добавьте методы для работы с этими атрибутами.
# Также проверьте, является ли ExtendedList подклассом list с помощью функции issubclass() и используйте super()
# для вызова методов суперкласса.
#
# Шаги:
# Создайте класс ExtendedList, который наследует от list.
# Добавьте private атрибут для хранения количества удалений элементов.
# Добавьте protected атрибут для хранения максимального размера списка.
# Добавьте метод append, который проверяет максимальный размер перед добавлением элемента.
# Добавьте метод remove, который увеличивает счетчик удалений при удалении элемента.
# Напишите методы для получения значений private и protected атрибутов.
# Проверьте, является ли ExtendedList подклассом list с помощью функции issubclass().

# def append(self, item):
#     if len(self) >= self._max_size:
#         print("Cannot add item: list is full")
#     else:
#         super().append(item)